/*
 * Title:   ADC.c
 * Device   ATmega16
 * Clock frequency: Частота кв.резонатора 9,216 МГц   
 *	учебная
***********************************************************************
	
1)	Программа осуществляет преобразование одного из
	8 аналоговых сигналов, подаваемых на вход порта А
2)	Выбор конкретного канала осуществляется кнопкой "Канал" PB7
3)	Номер выбранного канала отображается на семисегментном индикаторе.
4)	Частота преобразования задается при помощи таймера Т1
5)	Результат преобразования в виде 8 старших разрядов передается по
	интерфейсу RS-232 на ПК.
6)	Скорость обмена 19200 бод; Формат кадра:
	- старт-бит;
	- 8 бит данных;
	- бит паритета - нет;
	- один стоп бит
7)	Выводы USART:(TXD) PD1(выход)
8)	Передаваемый пакет состоит из одного байта
*/

/***********************************************************************
	Подключение библиотек
************************************************************************/
#include <avr/io.h>
//#include <avr/iom16.h> //Библитотека с описанием названий регистров и разрядов регистров
//Если среда разработки формирует макроопределение целевого микроконтроллера,
//то отдельно подключать не нужно
#include <avr/interrupt.h> //Библиотека для работы с прерываниями


/***********************************************************************
	Константные значения
************************************************************************/
#define DEB_NUM 35		// количество переполнений Т0 для подавления дребезга


/***********************************************************************
	Глобальные переменные
************************************************************************/
unsigned char adcNewData = 1;	// флаг обновления данных модулем АЦП
unsigned char result = 0;		// результат преобразования модулем АЦП
unsigned char number = 0;       // номер канала преобразования модулем АЦП
unsigned char flagDeb = 0;		// флаг запрещения опроса кнопки "Канал"
unsigned char time = 0;			// счетчик переполнения Т0 для подавления дребезга
								// кнопки "Канал"

/***********************************************************************
	Таблица перекодировки символов
************************************************************************/
const unsigned char table[] =
{	0xFC,	//код "0" - 0b11111100
	0x60,	//код "1" - 0b01100000
	0xDA,	//код "2" - 0b11011010
	0xF2,	//код "3" - 0b11110010
	0x66,	//код "4" - 0b01100110
	0xB6,	//код "5" - 0b10110110
	0xBE,	//код "6" - 0b10111110
	0xE0,	//код "7" - 0b11100000
	0xFE,	//код "8" - 0b11111110
	0xF6};	//код "9" - 0b11110110	

/***********************************************************************
	Прототипы функций
************************************************************************/
void InitPort(void);			// Инициализация портов В/B
void InitTimerT1(void);			// Инициализация таймера T1
void InitUSART(void);			// Инициализация модуля USART
void InitADC(void);				// Инициализация модуля АЦП
void ChangeChannel(void);		// Подпрограмма изменения канала преобразования


int main(void)
{
	//Инициализация необходимых периферийных модулей
	InitPort();		// Инициализация портов В/B
	InitTimerT1();	// Инициализация таймера T1
	InitUSART();	// Инициализация модуля USART
	InitADC();		// Инициализация модуля USART
	
	sei();	//Глобальное разрешение прерываний (определена в interrupt.h)
	
    while(1)
    {
        if(flagDeb != 1) //флаг flagDeb установлен?
		{				 //нет
			if((PINB & (1 << PINB7)) == 0)  // кнопка "Канал" (PB7) нажата?
			{
				ChangeChannel();// подпрограмма изменения канала преобразования
			}
		}
		if(adcNewData == 1)		// флаг adcNewData установлен?
		{						// да
			if ((UCSRA & (1<<UDRE)) != 0) // регистр данных пуст?
			{
				UDR = result;	// запись данных из result в регистр передачи
				adcNewData = 0;		// сброс флага adcNewData
			}						
		}		
    }
}

/***********************************************************************
	Инициализация портов В/B
************************************************************************/
void InitPort(void)
{	
	DDRA = 0b00000000;	// PA0...PA7 - входы
	PORTA = 0b00000000;	// выключены подтягивающие резисторы	
	
	DDRB = 0b01111111;	// PB7 - вход, остальные - выходы
	PORTB = 0b10000001;	// Разрешен первый индикатор
						// на входе PB7 - подтягивающие резисторы
		
	DDRC = 0b11111111;	// PС0...PС7 - выходы
	PORTC = 0b11111100;	// код "0" при включении
    
	DDRD = 0b00000010;	// PD1(TxD) - выход, PD0(RxD) - вход
	PORTD = 0b00000010; // PD1(TxD) - пассивное состояние лог. 1
}


/***********************************************************************
	Инициализация таймера T0 
	происходит в момент нажатия на кнопку "Просмотр".
	Выбирается нормальный режим с предделителем 1024
	время переполнения t=1024*256/9216000 = 28,4 мс
************************************************************************/
void InitTimerT0(void)
{
	TCCR0 = (1<<CS02)|(1<<CS00);    // запуск Т0 с предделителем 1024
	TIMSK |= 1<<TOIE0;				//Разрешение прерывания по переполнению Т0
}

/*********************************************************************** 
	Инициализация таймера T1
	Режим работы: CTC, предделитель 256, формируемое время: 1 с
************************************************************************/
void InitTimerT1(void)
{
	TCCR1B = (1<<WGM12)|(1<<CS12);// Выбор режима CTC, таймер включен с предделителем 256
	OCR1A = 0x8C9F;			// периодичность запуска АЦП = 1 с ->
							// 1*9216000/256=36000-1=35999 (8C9F)
	OCR1B = 0x8C9F;		// запись в регистр OCR1B для формирования события:
					// "Совпадение канала В", по которому запустится АЦП
} 


/*********************************************************************** 
	Инициализация модуля USART:
	скорость обмена 19200 бод, 8 бит данных, 1 стоп-бит, бит паритета - нет
************************************************************************/
void InitUSART(void)
{
	
	UBRRL = 29;					// Установка скорости обмена
	UBRRH = 0;					// UBRR = 9216000/(16*19200) - 1 = 29
	UCSRC = (1<<URSEL)|(1<<UCSZ0)|(1<<UCSZ1);// Формат кадра - 8 бит данных, без бита паритета
	UCSRB = (1<<TXEN);				// разрешение работы передатчика	
}

/*********************************************************************** 
	Инициализация модуля АЦП:
	Внутренний источник опорного напряжения 2,56В; нач канал - 0-ой;
	Запуск преобразования - по совпадению канала В таймера Т1;
	Выравнивание результата - по левому краю (считывается 8 ст. бит)
************************************************************************/
void InitADC(void)
{
	ADMUX = (0<<REFS1)|(1<<REFS0)|(1<<ADLAR);	// опорн. напр. - напр питания,
												// выравнивание - по левому краю
	SFIOR = (1<<ADTS2)|(1<<ADTS0);				// источник запуска -
												// совпадение канала В таймера Т1
	ADCSRA = (1<<ADEN)|(1<<ADATE)|(1<<ADIE)|(1<<ADPS2)|(1<<ADPS1);
												// разрешение АЦП и прерывания от него, режим
												// непрерывного преобр, предделитель - 64
}


/**************************************************
	Подпрограмма изменения канала преобразования
***************************************************/
void ChangeChannel(void)
{
	number++;
	if (number == 8) // number=8?(8 входных каналов)
	{
		number = 0;
	}
	//изменение канала преобразования
ADMUX &= ~((1<<MUX4)|(1<<MUX3)|(1<<MUX2)|(1<<MUX1)|(1<<MUX0));// сбросятся 0-4 разряды,
																	// остальные не изменятся
	ADMUX |=number;	
	PORTC = table[number];	// загрузка нового значения в регистр PORTC
	flagDeb = 1;			// установка флага необходимости подавления дребезга
	InitTimerT0();		// запуск таймера Т0 на формирования задержки	
}

/*******************************************************
	Подпрограмма обработки прерывания по завершению преобразования модуля АЦП
********************************************************/
ISR(ADC_vect)
{
	result = ADCH;		// чтение старшего регистра данных
	TIFR = (1<<OCF1B);  // сброс флага прерывания OCF1B в регистре TIFR записью лог. 1
	adcNewData = 1;   // установка флага adcNewData
}

/***********************************************************************
	Подпрограмма обработки прерывания по переполнению таймера Т0
************************************************************************/
ISR(TIMER0_OVF_vect)
{
	time++;
	if (time == DEB_NUM)		// необходимый таймаут сформирован
	{
		flagDeb = 0;			// сброс флага
		TCCR0 = 0x00;			// останов таймера
		TIMSK &= ~(1<<TOIE0);	// запрещение прерывания по переполнению Т0
		time = 0;
	}
}
