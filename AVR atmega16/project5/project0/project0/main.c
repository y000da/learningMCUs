/*
 * Title:   UART.c
 * Device   ATmega16
 * Clock frequency: Частота кв.резонатора 8 МГц 
 */ 

/*	учебная
Программа  осуществляет обмен по интерфейсу RS-232 между персональным компьютером
и стендом на основе микроконтроллера ATmega16 с портом  USART.
Преобразование в интерфейс RS-232 выполняется микросхемой Max232, установленной в стенде.
Передача/прием данных по USART осуществляется со следующими параметрами:
а)скорость обмена 19200бит/сек;
б)формат посылки 11 бит информации:
	-  старт-бит;
	-  8 бит данных;
	-  бит паритета - нет;
	-  один стоп бит.
Выводы USART(RXD) PD0 (вход),(TXD) PD1(выход)

При приеме кадра запроса  загорается светодиод "Прием", подключенный к PB7 ( выход)

Кадры принятых иданных можно просмотреть на семисегмент.индикаторах последовательно байт за байтом,
нажимая кнопку "Просмотр",подключенную к PB6( байт0, байт1, байт2, байт3, байт0..).
Крайний левый индикатор показываетномер номер просматриваемого байта
Кнопка "Ответ", инициализирующая ответную посылку микроконтр., подключена к PB5,при этом
светодиод "Прием" гаснет
семисегментные индикаторы подключены к PC0-PC7-выходы,семигегментный индикатор к  PC0-PC7
PC0-dp,PC1-g,PC2-f,PC3-e,PC4-d,PC5-c,PC6-b,PC7-a
сигналы выбора индикатора PB3-номер байта, PB1-старший полубайт,PB0-младший болубайт - выходы
*/

/***********************************************************************
	Подключение библиотек
************************************************************************/
#include <avr/io.h>
//#include <avr/iom16.h> //Библитотека с описанием названий регистров и разрядов регистров
//Если среда разработки формирует макроопределение целевого микроконтроллера,
//то отдельно подключать не нужно
#include <avr/interrupt.h> //Библиотека для работы с прерываниями

/***********************************************************************
	Константные значения
************************************************************************/
#define VAL_DISP 255	// Константа, задающее время активности индикатора при
						// динамической индикации
#define DEB_NUM 35		// количество переполнений Т0 для подавления дребезга
#define RX_NUM 4		// количество принимаемых байтов
#define TX_NUM 3		// количество передаваемых байтов

/***********************************************************************
	Глобальные переменные
************************************************************************/
unsigned char number = 0;			// номер байта для отражения на индикаторе
unsigned char hNibble = 0;			// значение старшего полубайта для отображения на индикаторе
unsigned char lNibble = 0;			// значение младшего полубайта для отображения на индикаторе
unsigned char counterDisplay =
				VAL_DISP;			// счетчик для динамической индикации
unsigned char numberDisplay = 3;	// номер активного семисегментного индикатора (номер байта)
unsigned char time = 0;				// счетчик переполнений Т0 для подавления дребезга кнопки "Просмотр"
unsigned char counterPackage = 0;	// счетчик переданных пакетов данных
unsigned char counterRx= 0;			// счетчик принятых байтов
unsigned char counterTx= 0;			// счетчик переданных байтов
unsigned char cSumRx= 0;			// контрольная сумма принятых байтов
unsigned char cSumTx= 0;			// контрольная сумма передаваемых байтов
unsigned char flagDeb = 0;			// флаг активности подавления дребезга от кнопки "Просмотр"
									// (0 - дребезг подавлен, 1 - идет подавление дребезга)
unsigned char flagReceive = 0;		// флаг получения пакета данных по USART
									// (0 - данные не получены, 1 - данные получены)									
volatile unsigned char flagTransmit = 0;// флаг завершения передачи данных по USART
									// (0 - передача не завершена, 1 - передача завершена)
									// volatile - отключение оптимизации для переменной

unsigned char bufRx[RX_NUM];		// буфер приема
unsigned char bufTx[TX_NUM];		// буфер передачи
unsigned char bufDisp[RX_NUM] = {0};// буфер для отображения принятых данных на индикаторе


/***********************************************************************
	Таблица перекодировки символов
************************************************************************/
const unsigned char table[] =
{	0xFC,	//код "0" - 0b11111100
	0x60,	//код "1" - 0b01100000
	0xDA,	//код "2" - 0b11011010
	0xF2,	//код "3" - 0b11110010
	0x66,	//код "4" - 0b01100110
	0xB6,	//код "5" - 0b10110110
	0xBE,	//код "6" - 0b10111110
	0xE0,	//код "7" - 0b11100000
	0xFE,	//код "8" - 0b11111110
	0xF6,	//код "9" - 0b11110110
	0xEE,	//код "А" - 0b11101110
	0x3E,	//код "b" - 0b00111110
	0x9C,	//код "С" -	0b10011100
	0x7A,	//код "d" - 0b01111010
	0x9E,	//код "E" - 0b10011110
	0x8E,	//код "F" - 0b10001110
	0x00};	//код погашенного индикатора - 0b00000000
/***********************************************************************
	Прототипы функций
************************************************************************/
void InitPort(void);			// Инициализация портов В/B
void InitTimerT0(void);			// Инициализация таймера T0
void InitTimerT1(void);			// Инициализация таймера T1
void InitUSART(void);			// Инициализация модуля USART
void Display(void);				// Подпрограмма динамической индикации
void CopyData (void);			// Подпрограмма копирования данных в буфер индикатора
void ChangeDataToDisplay(void);	// Подпрограмма изменения позиции просмотра
void PrepDataForTx(void);		// Подпрограмма подготовки данных к передаче

/***********************************************************************
Главная программа
************************************************************************/
int main(void)
{	
	//Инициализация необходимых периферийных модулей
	InitPort();		//Инициализация портов В/B
	InitTimerT1();	//Инициализация таймера T1
	InitUSART();	//Инициализация модуля USART
	
	sei();	//Глобальное разрешение прерываний (определена в interrupt.h)
						
	//Основной цикл					
	while(1)
    {
		Display(); // Периодический вызов подпрограммы динамической индикации
		// Проверка флага получения пакета по USART
		if(flagReceive == 1)
	{
		flagReceive = 0;		// сброс флага
		PORTB |= 1 << PINB7;	// включение светодиода
	       CopyData ();		// копирование данных в буфер индикатора
		
		while ((PINB & (1 << PINB5)) != 0)// ожидание нажатия кнопки "Ответ" (PB5)
		{
			Display(); // Периодический вызов подпрограммы динамической индикации
			if(flagDeb == 0) // Дребезг от прошлого нажатия уже подавлен
			{
			if ((PINB & (1 << PINB6)) == 0)	// кнопка "Просмотр" (PB6) нажата?
				{
				ChangeDataToDisplay();		// изменение позиции просмотра
					}
				}
			}
		PrepDataForTx();					// подготовка данных к передаче
		UCSRB &= ~((1<<RXEN)|(1<<RXCIE));	// запрещение приемника и прерывания от него
		UCSRB |= (1<<TXEN)|(1<<UDRIE);// разрешение передатчика и прерываний от него
		while(flagTransmit == 0);			// ожидание завершения передачи
		flagTransmit = 0;					// сброс флага
		PORTB &= ~(1 << PINB7);				// выключение светодиода		
		}
		else
		{
			if(flagDeb == 0) // Дребезг от прошлого нажатия уже подавлен
			{
			if ((PINB & (1 << PINB6)) == 0)	// кнопка "Просмотр" (PB6) нажата?
				{
				ChangeDataToDisplay();		// изменение позиции просмотра
				}
			}
}	
	}		
}

/***********************************************************************
	Инициализация портов В/B
************************************************************************/
void InitPort(void)
{	
	DDRA = 0b00000000;	// PA0...PA7 - входы
	PORTA = 0b11111111;	// включены подтягивающие резисторы	
	
	DDRB = 0b10011111;	// PB5,PB6 - входы, остальные - выходы
	PORTB = 0b01101000;	// выбран номер байта (4-й индикатор)
						// на входах PB5 и PB6 - подтягивающие резисторы
		
	DDRC = 0b11111111;	// PС0...PС7 - выходы
	PORTC = 0b11111100;	// код "0" при включении
    
	DDRD = 0b00000010;	// PD1(TxD) - выход,PD0(RxD)-вход
	PORTD = 0b00000010;	// пассивное состояние - лог. 1
}


/***********************************************************************
	Инициализация таймера T0 
	происходит в момент нажатия на кнопку "Просмотр". Выбирается
	нормальный режим с предделителем 1024
	время переполнения t=1024*256/9216000 = 29 мс
************************************************************************/
void InitTimerT0(void)
{	
	TCCR0 = (1<<CS02)|(1<<CS00);	//Разрешение работы таймера с предделителем 1024
	TIMSK |= 1<<TOIE0;				//Разрешение прерывания по переполнению Т0	
}

/*********************************************************************** 
	Инициализация таймера T1
	Режим работы: CTC, предделитель 1, формируемое время:
	от 1/9216000 до 65536/9216000 с = от 0,108 мкс до 7,1 мс
************************************************************************/
void InitTimerT1(void)
{
	TCCR1B = (1<<WGM12);			// Режим CTC с TOP = OCR1A, таймер выключен
	OCR1A = 0xD800;					// time_out = 6 мс -> 0,006*9216000=55296(D800)
									// компилятор сам сформирует доступ к 16-разрядному регистру
} 

/*********************************************************************** 
	Инициализация модуля USART:
	скорость обмена 19200 бод, 8 бит данных, 1 стоп-бит, бит паритета - нет
************************************************************************/
void InitUSART(void)
{
	
	UBRRL = 29;									// Установка скорости обмена
	UBRRH = 0;									// UBRR = 9216000/(16*BOD)-1
	UCSRC = (1<<URSEL)|(1<<UCSZ0)|(1<<UCSZ1);	// Формат кадра - 8 бит данных, без бита паритета
UCSRB = (1<<RXEN)|(1<<RXCIE);				// Разрешение работы приемника и прерывания по завершению приема	
}

/***********************************************************************
	Подпрограмма динамической индикации
************************************************************************/
void Display(void)
{
	counterDisplay--;	// Уменьшение счетчика времени активности индикатора
	if (counterDisplay == 0)
	{
		counterDisplay = VAL_DISP;	// Загрузка счетчика для реализации
									// динамической индикации
		
		numberDisplay--;			// переход на следующий индикатор
		if(numberDisplay == 255)	// т.к. переменная беззнаковая
		{
			numberDisplay = 3;
		}
		
		switch(numberDisplay)
		{
			case 3:
			PORTC = table[number];	// Загрузка нового значения в регистр PORTC
			PORTB &= ~(1<<0);		// Выключение индикатора lNibble
			PORTB |= (1<<3);		// Включение индикатора number
			break;
			
			case 2:
			PORTC = table[16];		// Загрузка нового значения в регистр PORTC
			PORTB &= ~(1<<3);		// Выключение индикатора number
			PORTB |= (1<<2);		// Включение индикатора пробел
			break;
			
			case 1:
			PORTC = table[hNibble];	// Загрузка нового значения в регистр PORTC
			PORTB &= ~(1<<2);		// Выключение индикатора пробел
			PORTB |= (1<<1);		// Включение индикатора hNibble
			break;
			
			case 0:
			PORTC = table[lNibble];	// Загрузка нового значения в регистр PORTC
			PORTB &= ~(1<<1);		// Выключение индикатора hNibble
			PORTB |= (1<<0);		// Включение индикатора lNibble
			break;			
		}
	}
} 	

/***********************************************************************
Подпрограмма копирования данных в буфер индикатора
************************************************************************/
void CopyData(void)
{
	unsigned char i; // итератор цикла
	
	for(i = 0; i < RX_NUM; i++)
	{
		bufDisp[i] = bufRx[i];
	}

}

/***********************************************************************
Подпрограмма изменения позиции просмотра
************************************************************************/
void ChangeDataToDisplay(void)
{
	unsigned char temp;	// переменная для временного хранения
	
	number++;	// переход на следующий байт принятого пакета
	if (number == 4)
	{
		number = 0;
	}
	
	temp = bufDisp[number];			// считывание байта из буфера индикатора
	lNibble = temp & 0x0F;			// выделение младшего полубайта
	hNibble = (temp >> 4) & 0x0F;	// выделение старшего полубайта
	
	flagDeb = 1;					// установка флага необходимости подавления дребезга
	InitTimerT0();					// запуск таймера T0
}

/***********************************************************************
Подпрограмма подготовки данных к передаче
************************************************************************/
void PrepDataForTx(void)
{
	unsigned char i; // итератор цикла
	
	cSumTx = 0;			// сброс аккумулятора контрольной суммы передаваемого пакета
	counterPackage++;	// увеличение счетчика пакетов 

	bufTx[0] = counterPackage;
	bufTx[1] = PINA;
	
	for(i = 0; i < TX_NUM-1; i++)
	{
		cSumTx += bufTx[i];	// накопление контрольной суммы
	}
	
	bufTx[TX_NUM-1] = cSumTx;
}


/***********************************************************************
	Подпрограмма обработки прерывания по завершению приема USART
************************************************************************/
ISR(USART_RXC_vect)
{
	unsigned char flags, data;		//переменные для временного хранения
	
	data = UDR;			// чтение принятых данных
	flags = UCSRA;		// чтение флагов ошибок
	if ((flags & ((1<<FE)|(1<<DOR)|(1<<PE))) == 0)	//если отсутствую ошибки при приеме
	{
		bufRx[counterRx] = data;	// сохранение данных в буфере приема
		counterRx++;
		if(counterRx == 1)	// если самый первый байт пакета
		{
			cSumRx += data;			// накопление контрольной суммы		
			TIMSK |= 1<<OCIE1A;		// разрешение прерывания по совпадению канала А Т1
			TCCR1B |= 1<<CS10;		// запуск таймера с предделителем N = 1
		}
	else if(counterRx == RX_NUM) // если самый последний байт
		{
			if(cSumRx == data)		// контрольная сумма верна
			{
				flagReceive = 1;	// установка флага получения пакета данных
			}
		TIMSK &= ~(1<<OCIE1A);	// запрещение прерывания по совпадению канала А Т1
			TCCR1B &= ~(1<<CS10);	// останов таймера
			TCNT1 = 0;				// очистка счетного регистра
			counterRx = 0;			// очистка счетчика принятых байтов
		cSumRx = 0;				// очистка аккумулятора контрольной суммы
		}
		else
		{
			cSumRx += data;			// накопление контрольной суммы	
		}
	}
}

/***********************************************************************
	Подпрограмма обработки прерывания "Регистр данных USART пуст"
************************************************************************/
ISR(USART_UDRE_vect)
{
	UCSRB &= ~(1<<UDRIE);	// запрещение прерывания "Регистр данных USART пуст"
	UCSRB |= (1<<TXCIE);	// разрешение прерывания по завершению передачи USART
	
	UDR = bufTx[0];			// начало передачи пакета
}

/***********************************************************************
	Подпрограмма обработки прерывания по завершению передачи USART
************************************************************************/
ISR(USART_TXC_vect)
{
	counterTx++;				// подсчет количества переданных байтов
	if (counterTx == TX_NUM)	// завершение передачи
	{
		counterTx = 0;			// сброс счетчика
	UCSRB &= ~((1<<TXEN)|(1<<TXCIE));	// запрещение передатчика и прерываний от него
		UCSRB |= (1<<RXEN)|(1<<RXCIE);	// разрешение приемника и прерывания от него
		flagTransmit = 1;				// установка флага завершения передачи
	}
	else
	{
		UDR = bufTx[counterTx];				// продолжение передачи
	}
}

/***********************************************************************
	Подпрограмма обработки прерывания по совпадению канала А таймера Т1
************************************************************************/
ISR(TIMER1_COMPA_vect)
{
	TIMSK &= ~(1<<OCIE1A);	// запрещение прерывания по совпадению канала А Т1
	TCCR1B &= ~(1<<CS10);	// останов таймера
	TCNT1 = 0;				// очистка счетного регистра
	counterRx = 0;			// очистка счетчика принятых байтов
	cSumRx = 0;				// очистка аккумулятора контрольной суммы
}

/***********************************************************************
	Подпрограмма обработки прерывания по переполнению таймера Т0
************************************************************************/
ISR(TIMER0_OVF_vect)
{
	time++;
	if (time == DEB_NUM)		// необходимый таймаут сформирован
	{
		flagDeb = 0;			// сброс флага
		TCCR0 = 0x00;			// останов таймера
		TIMSK &= ~(1<<TOIE0);	// запрещение прерывания по переполнению Т0
		time = 0;
	}
}
