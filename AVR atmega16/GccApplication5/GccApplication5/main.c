/*
 * Title:   timer.c
 * Device   ATmega16
 * Clock frequency: Частота кв.резонатора 8 МГц 
 */ 

/*	учебная
*************************************
	Назначение:
1)  формирует "бегущий огонек" на светодиодах, подключенных к PORTA;
	по внешнему прерыванию INT0 изменяется направление огонька;
	по внешнему прерыванию INT1 изменяется скорость огонька
2)  формирует сигнал с ШИМ на выходе совпадения канала В таймера Т1
	кнопки PB4 и PB5 уменьшают и увеличивают скважность сигнала;
	текущее значение скважности в процентах выводится на индикаторы,
	подключенные к PORTC
*/

/***********************************************************************
	Подключение библиотек
************************************************************************/
#include <avr/io.h>
//#include <avr/iom16.h> //Библитотека с описанием названий регистров и разрядов регистров
//Если среда разработки формирует макроопределение целевого микроконтроллера,
//то отдельно подключать не нужно
#include <avr/interrupt.h> //Библиотека для работы с прерываниями

/***********************************************************************
	Константные значения
************************************************************************/
#define VAL_DISP 255	// Константа, задающее время активности индикатора при
						// динамической индикации
#define MIN_VEL 32		// минимальная скорость огоньков (условное значение)
#define MAX_VEL 2		// максимальная скорость огоньков (условное значение)
#define INIT_DUTY 10	// начальная скважность
#define DEB_NUM 10		// количество переполнений Т0 для подавления дребезга

/***********************************************************************
	Глобальные переменные
************************************************************************/
unsigned char counter = 0;			// счетчик числа переполнений Т0
unsigned char maxCounter = MAX_VEL;	// максимальное значение для счетчика counter
									// определяет скорость переключения "огоньков"	
unsigned char debounceInt0 = 0;		// счетчик для подавления дребезга от INT0
unsigned char debounceInt1 = 0;		// счетчик для подавления дребезга от INT1
unsigned char debouncePB = 0;		// счетчик для подавления дребезга от PB4 и PB5
unsigned char counterDisplay =
				VAL_DISP;			// счетчик для динамической индикации
unsigned char duty = INIT_DUTY;		// значение скважности регистра совпадения канала В 
unsigned char tens = 0;				// число десятков для отображения на индикаторе
unsigned char ones = 0;				// число единиц для отображения на индикаторе
unsigned char dispNum = 0;			// номер активного индикатора (0 - tens, 1 - ones)
unsigned char flagPB = 0;			// флаг активности подавления дребезга от кнопок PB4 и PB5
									// (0 - дребезг подавлен, 1 - идет подавление дребезга)
unsigned char flagInt0 = 0;			// флаг активности подавления дребезга от кнопки INT0
									// (0 - дребезг подавлен, 1 - идет подавление дребезга)
unsigned char flagInt1 = 0;			// флаг активности подавления дребезга от кнопки INT1
									// (0 - дребезг подавлен, 1 - идет подавление дребезга)
unsigned char direction = 0;		// флаг направления движения бегущего огонька

/***********************************************************************
	Таблица перекодировки символов
************************************************************************/
const unsigned char table[] =
{	0xFC,	//код "0" - 0b11111100
	0x60,	//код "1" - 0b01100000
	0xDA,	//код "2" - 0b11011010
	0xF2,	//код "3" - 0b11110010
	0x66,	//код "4" - 0b01100110
	0xB6,	//код "5" - 0b10110110
	0xBE,	//код "6" - 0b10111110
	0xE0,	//код "7" - 0b11100000
	0xFE,	//код "8" - 0b11111110
	0xF6};	//код "9" - 0b11110110	


/***********************************************************************
	Прототипы функций
************************************************************************/
void InitPort(void);		// Инициализация портов В/B
void InitTimerT0(void);		// Инициализация таймера T0
void InitTimerT1(void);		// Инициализация таймера T1
void InitExtInt(void);		// Инициализация внешних прерываний INT0, INT1
void Display(void);			// Подпрограмма динамической индикации
void DigitConvert (unsigned char dataIn, unsigned char *tensOut, unsigned char *onesOut);
							// Подпрограмма преобразования значения duty
							// в двоично-десятичный код tens, ones

/***********************************************************************
Главная программа
************************************************************************/
int main(void)
{	
	//Инициализация необходимых периферийных модулей
	InitPort();		//Инициализация портов В/B
	InitTimerT0();	//Инициализация таймера T0
	InitTimerT1();	//Инициализация таймера T1
	InitExtInt();	//Инициализация внешних прерываний INT0, INT1

	//Формирование значения tens и ones при включении питания
	//tens и ones передаются в функцию по адресу
	DigitConvert(duty, &tens, &ones);	
	
	sei();	//Глобальное разрешение прерываний (определена в interrupt.h)
						
	//Основной цикл					
	while(1)
    {
		Display(); // Периодический вызов подпрограммы динамической индикации
		// Проверка флага об активном состоянии подавления дребезга
		if (flagPB == 0) // Дребезг от прошлого нажатия уже подавлен
		{
			if ((PINB & (1 << PINB4)) == 0) // Кнопка PB4 нажата?
			{
				if(duty != INIT_DUTY)
				{
					duty -= INIT_DUTY;	// Уменьшение значения duty на INIT_DUTY
					OCR1B = duty;		// Загрузка duty в OCR1B
					DigitConvert(duty, &tens, &ones); // Преобразование duty в tens и ones	
				}
				// для защиты от дребезга формируется пауза в DEB_NUM
				// переполнений Т0
				debouncePB = DEB_NUM;  // Инициализация debouncePB
				flagPB = 1; // Установка флага о необходимости подавления дребезга
				while (flagPB != 0 || (PINB & (1 << PINB4)) == 0) // Ожидание подавления дребезга и отпускания кнопки
				{
					Display(); // Периодический вызов подпрограммы динамической индикации
				}
				debouncePB = DEB_NUM;  // Инициализация debouncePB
				flagPB = 1; // Установка флага о необходимости подавления дребезга
			}
			else if ((PINB & (1 << PINB5)) == 0) // кнопка PB5 нажата?
			{
				if(duty != 190) //Маскимальное значение
				{
					duty += INIT_DUTY;	// УВеличение значения duty на INIT_DUTY
					OCR1B = duty;		// Загрузка duty в OCR1B
					DigitConvert(duty, &tens, &ones); // Преобразование duty в tens и ones	
				}
				// для защиты от дребезга формируется пауза в DEB_NUM
				// переполнений Т0
				debouncePB = DEB_NUM;  // Инициализация debouncePB
				flagPB = 1; // Установка флага о необходимости подавления дребезга
				while (flagPB != 0 || (PINB & (1 << PINB5)) == 0) // Ожидание подавления дребезга и отпускания кнопки
				{
					Display(); // Периодический вызов подпрограммы динамической индикации
				}
				debouncePB = DEB_NUM;  // Инициализация debouncePB
				flagPB = 1; // Установка флага о необходимости подавления дребезга
			}
		}
	}		
}

/***********************************************************************
	Инициализация портов В/B
************************************************************************/
void InitPort(void)
{	
	DDRA = 0b11111111;	// PA0...PA7 - выходы (подключены к светодиодам)
	PORTA = 0b00000001;	// один светодиод включен	
	
	DDRB = 0b11001111;	// PB4,PB5 - входы, остальные - выходы
	PORTB = 0b00110010;	// выбраны десятки (2-й индикатор)
						// на входах PB4 и PB5 - подтягивающие резисторы
		
	DDRC = 0b11111111;	// PС0...PС7 - выходы
	PORTC = 0b11111100;	// код "0" при включении
    
	DDRD = 0b11110011;	// PD2(INT0),PD3(INT1)-входы
	PORTD = 0b00001100;	// Подтягивающие резисторы на входах
}


/***********************************************************************
	Инициализация таймера T0 
	Время переполнения таймера: t = 256*1024/8000000 = 33 мс
************************************************************************/
void InitTimerT0(void)
{
	TCCR0 = (1<<CS02)|(1<<CS00);	//Разрешение работы таймера с предделителем 1024
	TIMSK |= 1<<TOIE0;				//Разрешение прерывания по переполнению Т0
}

/*********************************************************************** 
	Инициализация таймера T1
	Режим работы: Fast PWM с TOP = 0x00FF, выходная частота:
	8000000 Гц / (8*256) = 3906,25 Гц
************************************************************************/
void InitTimerT1(void)
{
	TCCR1A = (1<<COM1B1)|(1<<WGM11);	// Разрешение выхода канала В
	TCCR1B = (1<<WGM13)|(1<<CS11);
	ICR1 = 199;                         // Режим Fast PWM с ICR = 199
	// Разрешение работы с предделителем 8
	OCR1B = INIT_DUTY;					// Задание начальной скважности
	// компилятор сам сформирует доступ к 16-разрядному регистру
} 

/*********************************************************************** 
	Инициализация внешних прерываний INT0, INT1
	Условние прерывания - любое изменение уровня
************************************************************************/
void InitExtInt(void)
{
	MCUCR |= (1<<ISC10)|(1<<ISC00);	// Задание условия прерывания: любое изменение уровня
	GICR |= (1<<INT1)|(1<<INT0);	// Разрешение INT0 и INT1	
}

/***********************************************************************
Подпрограмма преобразования значения duty
в двоично-десятичный код tens, ones
************************************************************************/
void DigitConvert (unsigned char dataIn, unsigned char *tensOut, unsigned char *onesOut)
{
	unsigned char percent; // Промежуточная переменная для преобразования в проценты

	percent = ((unsigned short)dataIn)*100/199; // Преобразование из диапазона 0..255 в диапазон 0..100
												// В процессе преобразование происходит выход за границу типа,
												// поэтому сначала делается явное преобразование типа

	*onesOut = percent%10;	// Определение количества единиц (остаток от деления на 10)
	*tensOut = percent/10;	// Определение количества десятков (целочисленное деление на 10)	
}

/***********************************************************************
	Подпрограмма динамической индикации
************************************************************************/
void Display(void)
{
	counterDisplay--;	// Уменьшение счетчика времени активности индикатора
	if (counterDisplay == 0)
	{
		counterDisplay = VAL_DISP;	// Загрузка счетчика для реализации
									// динамической индикации
		
		// Переключение индикаторов
		if (dispNum != 0)	// Переключение на tens
		{
			PORTC = table[tens];	// Загрузка нового значения в регистр PORTC
			PORTB &= ~(1<<0);		// Выключение индикатора ones
			PORTB |= (1<<1);		// Включение индикатора tens
			dispNum = 0;
		}
		else // Переключение на ones
		{
			PORTC = table[ones];	// Загрузка нового значения в регистр PORTC
			PORTB &= ~(1<<1);		// Выключение индикатора tens
			PORTB |= (1<<0);		// Включение индикатора ones
			dispNum = 1;
		}
	}
} 	

/***********************************************************************
	Подпрограмма обработки внешнего прерывания INT0 (кнопка PD2)
************************************************************************/
ISR(INT0_vect)
{
	if ((PIND & (1 << PIND2)) == 0) // PD2 = 0? 
	{   
		//Изменение direction
		if(direction == 0) direction = 1;
		else direction = 0;
	}
	GICR &= ~(1<<INT0); // Запрет прерывания INT0
	// для защиты от дребезга формируется пауза в DEB_NUM
	// переполнений Т0
	flagInt0 = 1;
	debounceInt0 = DEB_NUM;
}

/***********************************************************************
	Подпрограмма обработки внешнего прерывания INT1 (кнопка PD3)
************************************************************************/
ISR(INT1_vect)
{
	if ((PIND & (1 << PIND3)) == 0) // PD3 = 0? 
	{
		if( maxCounter == MIN_VEL)
		{
			counter = 0;
			maxCounter = MAX_VEL;
		}
		else maxCounter*=2;
	}
	GICR &= ~(1<<INT1); // Запрет прерывания INT1
	// для защиты от дребезга формируется пауза в DEB_NUM
	// переполнений Т0
	flagInt1 = 1;
	debounceInt1 = DEB_NUM;
}

/***********************************************************************
	Подпрограмма обработки прерывания по переполнению таймера Т0
************************************************************************/
ISR(TIMER0_OVF_vect)
{
	unsigned char temp; // Для временного хранения
	
	// Управление "бегущим огоньком"
	counter++;
	if (counter == maxCounter) //Переключение активного светодиода
	{  
		counter = 0;
		temp = PORTA;
		if(direction == 1)
		{
			temp = temp << 1; // Логический сдвиг влево
			if (temp == 0) // Было переполнение?
			{
				temp = 0x01; // Начальная инициализация
			}
		}
		else
		{
			temp = temp >> 1; // Логический сдвиг вправо
			if (temp==0) // Было переполнение?
			{
				temp = 0x80; // Начальная инициализация
			}
		}
		PORTA = temp;	
	}

	//Подавление дребезга контактов INT0
	if (flagInt0 == 1)
	{
		debounceInt0--;
		if (debounceInt0 == 0)
		{
			flagInt0 = 0;		// Сброс программного флага	
			GIFR = (1<<INTF0);	// Сброс флага прерывания
			GICR |=(1<<INT0);	// Разрешение прерывания					
		}
	}

	//Подавление дребезга контактов INT1
	if (flagInt1 == 1)
	{
		debounceInt1--;
		if (debounceInt1 == 0)
		{
			flagInt1 = 0;		// Сброс программного флага	
			GIFR = (1<<INTF1);	// Сброс флага прерывания
			GICR |=(1<<INT1);	// Разрешение прерывания					
		}
	}

	//Подавление дребезга контактов PB4 и PB5
	if (flagPB == 1)
	{
		debouncePB--;
		if (debouncePB == 0) flagPB = 0; // Сброс программного флага	
	}
}

